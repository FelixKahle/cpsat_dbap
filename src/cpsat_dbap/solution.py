# Copyright (c) 2026 Felix Kahle.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from dataclasses import dataclass, field, InitVar

@dataclass(frozen=True)
class Solution:
    """
    Represents a specific allocation and scheduling solution.
    
    Fields calculated during initialization:
    - vessel_turnaround_times
    - vessel_weighted_turnaround_times
    - total_turnaround_time
    - total_weighted_turnaround_time
    """
    vessel_berths: list[int]
    vessel_start_times: list[int]
    vessel_end_times: list[int]
    
    # Inputs required for calculation (not stored in final object)
    weights: InitVar[list[int]]
    arrival_times: InitVar[list[int]]

    # Derived fields
    vessel_turnaround_times: list[int] = field(init=False)
    vessel_weighted_turnaround_times: list[int] = field(init=False)
    total_turnaround_time: int = field(init=False)
    total_weighted_turnaround_time: int = field(init=False)

    def __post_init__(self, weights: list[int], arrival_times: list[int]):
        n = len(self.vessel_berths)

        if len(self.vessel_start_times) != n:
            raise ValueError("start times length mismatch")
        if len(self.vessel_end_times) != n:
            raise ValueError("end times length mismatch")
        if len(weights) != n:
            raise ValueError("weights length mismatch")
        if len(arrival_times) != n:
            raise ValueError("arrival_times length mismatch")

        turnaround = []
        weighted = []
        total_ta = 0
        total_wta = 0

        for i in range(n):
            start = self.vessel_start_times[i]
            end = self.vessel_end_times[i]
            arrival = arrival_times[i]
            w = weights[i]

            if end < start:
                raise ValueError(f"end < start for vessel {i}")

            # --- CORRECTION HERE ---
            # Old: ta = end - start  (This was just processing time)
            # New: ta = end - arrival (This is true Turnaround/Flow time)
            ta = end - arrival 
            
            wta = ta * w

            turnaround.append(ta)
            weighted.append(wta)
            total_ta += ta
            total_wta += wta

        object.__setattr__(self, 'vessel_turnaround_times', turnaround)
        object.__setattr__(self, 'vessel_weighted_turnaround_times', weighted)
        object.__setattr__(self, 'total_turnaround_time', total_ta)
        object.__setattr__(self, 'total_weighted_turnaround_time', total_wta)

    @property
    def num_vessels(self) -> int:
        return len(self.vessel_berths)

    @property
    def makespan(self) -> int:
        if not self.vessel_end_times:
            return 0
        return max(self.vessel_end_times)
    
    @property
    def mean_turnaround_time(self) -> float:
        if self.num_vessels == 0:
            return 0.0
        return self.total_turnaround_time / self.num_vessels

    def validate(self) -> bool:
        """
        Checks internal consistency. Raises ValueError on failure.
        """
        n = self.num_vessels

        # Check vector lengths
        arrays = [
            self.vessel_start_times,
            self.vessel_end_times,
            self.vessel_turnaround_times,
            self.vessel_weighted_turnaround_times
        ]
        
        for vec in arrays:
            if len(vec) != n:
                raise ValueError("Vector length mismatch in solution state")

        # Check timing logic
        for i in range(n):
            if self.vessel_end_times[i] < self.vessel_start_times[i]:
                raise ValueError(f"Invalid timing at vessel {i}")

        return True

    def __str__(self) -> str:
        return (
            f"Solution({self.num_vessels} vessels, "
            f"total_turnaround={self.total_turnaround_time}, "
            f"weighted={self.total_weighted_turnaround_time})"
        )

    # __eq__ and __hash__ are automatically generated by @dataclass
    # based on the fields. Since we want equality to check all fields
    # (including the derived ones), the default dataclass behavior 
    # is correct as long as we don't exclude them from comparison.